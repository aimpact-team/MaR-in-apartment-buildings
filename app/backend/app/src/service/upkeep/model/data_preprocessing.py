import pandas as pd
import numpy as np


def prepare_df_1(df_1: pd.DataFrame):
    # подготовка 1 табл
    old_names = list(df_1)
    new_names = [
        "ID_object",
        "Address_object",
        "PARENT_ID",
        "LOGIN",
        # "Назначение",
        "Форма собственности",
        "Год постройки",
        "Год реконструкции",
        "Серия проекта",
        "Количество этажей",
        "Количество подъездов",
        "Количество квартир",
        "Общая площадь",
        "Общая площадь жилых помещений",
        "Общая площадь нежилых помещений",
        "Строительный объем",
        "Износ объекта (по БТИ)",
        "Класс энергоэффективности",
        "Материал стен",
        "Признак аварийности здания",
        "Количество пассажирских лифтов",
        "Количество грузопассажирских лифтов",
        "Очередность уборки кровли",
        "Материал кровли",
        "unom",
        # "Вид социального объекта",
        "Тип жилищного фонда",
        "Статус МКД",
        "Статус управления МКД",
        "Количество грузовых лифтов",
        "Причина Изменения Статуса МКД",
        "Категория МКД",
    ]
    new_col = dict(zip(old_names, new_names))
    df_1 = df_1[1:].rename(columns=new_col)
    df_1.unom = df_1.unom.astype(int)

    df_1 = df_1.fillna(0)

    # приведем типы данных к верным
    column_int_list = [
        "ID_object",
        "Год постройки",
        "Количество этажей",
        "Количество подъездов",
        "Количество квартир",
        "Количество пассажирских лифтов",
        "Количество грузопассажирских лифтов",
        "Количество грузовых лифтов",
        "Серия проекта",
        "Материал стен",
        "Признак аварийности здания",
        "Очередность уборки кровли",
        "Материал кровли",
        "Тип жилищного фонда",
    ]
    for column in column_int_list:
        df_1[column] = df_1[column].astype(int)

    column_float_list = [
        "Общая площадь",
        "Общая площадь жилых помещений",
        "Общая площадь нежилых помещений",
    ]

    for column in column_float_list:
        df_1[column] = df_1[column].astype(float)

    # добавим общее Количество лифтов
    df_1["num_lift"] = (
        df_1["Количество пассажирских лифтов"]
        + df_1["Количество грузопассажирских лифтов"]
        + df_1["Количество грузовых лифтов"]
    )

    # добавим наличие лифтов в доме
    df_1["Is_lift"] = df_1["num_lift"] > 0
    df_1 = df_1.dropna()

    return df_1


def create_df_1_2(df_1: pd.DataFrame, df_2: pd.DataFrame):
    df_1 = prepare_df_1(df_1)

    # разделим данные инцидентов по жалобам и датчики
    df_incident = df_2[df_2["source"] != "ASUPR"]  # жалобы

    # К каждому дому добавим инфо о кол-ве заявок кол-во проблем с датчиков
    df_1_2 = df_1.merge(
        df_incident.groupby("unom").size().rename("num_incident"), how="left", on="unom"
    )

    # отфильтруем слишком большое число обращений
    df_1_2 = df_1_2.drop(
        np.where(df_1_2["num_incident"] > (df_1_2.num_incident.max() * 0.8))[0]
    )
    df_1_2 = df_1_2.dropna()

    return df_1_2


def columns_num_inc_model():
    # выберем колонки для обучения модели для предсказания кол-ва инцидентов
    target_col = ["num_incident"]
    num_cols = [
        "Количество этажей",
        "Количество подъездов",
        "Количество квартир",
        "Общая площадь",
        "num_lift",
    ]
    cat_cols = [
        "Серия проекта",
        "Материал стен",
        "Материал кровли",
        "Тип жилищного фонда",
        "Статус МКД",
        "Is_lift",
    ]
    return target_col, num_cols, cat_cols

def create_df_3_4(df_3: pd.DataFrame, df_4: pd.DataFrame):
    # подготовка 3 табл. некоторые данные не совпадают, приведем к стандарту
    df_3_ = df_3.copy()

    old_name = list(set(df_3["name"]).difference(df_4["Наименование"]))
    new_name = [
        "ремонт или замена мусоропровода",
        "ремонт фасада (замена оконных блоков, расположенных в помещениях общего пользования в многоквартирном доме)",
        "ремонт подвальных помещений, относящихся к общему имуществу собственников помещений",
        "ремонт фасада",
        "ремонт или замена внутреннего водостока",
        "ремонт внутридомовых инженерных сетей электроснабжения",
        "ремонт подъездов, направленный на восстановление их надлежащего состояния и проводимый при выполнении иных работ",
    ]
    df_3_["name"] = df_3_["name"].replace(old_name, new_name)

    # Соединим табл 3 и 4 (проводимый в 2022 г кап рем и виды работ по кап рем)
    df_3_4 = df_3_.merge(df_4, how="inner", left_on="name", right_on="Наименование")
    df_3_4 = df_3_4.drop(columns="Наименование")
    return df_3_4

def columns_num_works_model():
    # выберем колонки для обучения модели для предсказания кол-ва инцидентов
    target_col = ['замена лифтового оборудования',
                'ремонт внутридомовых инженерных систем водоотведения (канализации) (выпуски и сборные трубопроводы)',
                'ремонт внутридомовых инженерных систем теплоснабжения (разводящие магистрали)',
                'ремонт внутридомовых инженерных систем холодного водоснабжения (разводящие магистрали)',
                'ремонт внутридомовых инженерных систем горячего водоснабжения (разводящие магистрали)',
                'ремонт или замена мусоропровода',
                'ремонт внутридомовых инженерных систем газоснабжения',
                'ремонт фасада (замена оконных блоков, расположенных в помещениях общего пользования в многоквартирном доме)',
                'ремонт подъездов, направленный на восстановление их надлежащего состояния и проводимый при выполнении иных работ',
                'ремонт крыши',
                'ремонт внутридомовых инженерных сетей электроснабжения',
                'ремонт фасада',
                'ремонт или замена внутреннего водостока',
                'ремонт внутридомовых инженерных систем горячего водоснабжения (стояки)',
                'ремонт пожарного водопровода',
                'ремонт внутридомовых инженерных систем теплоснабжения (стояки)',
                'ремонт внутридомовых инженерных систем холодного водоснабжения (стояки)',
                'ремонт подвальных помещений, относящихся к общему имуществу собственников помещений',
                'ремонт внутридомовых инженерных систем водоотведения (канализации) (стояки)']
    num_cols = ['Количество этажей',
                'Количество подъездов',
                'Количество квартир',
                'Общая площадь',
                'num_lift',
                'num_inc_pred',
                'Год постройки'
                ]
    cat_cols = ['Серия проекта',
                'Материал стен',
                'Материал кровли',
                'Тип жилищного фонда',
                'Статус МКД',
                'Is_lift'
                ]
    return target_col, num_cols, cat_cols

def create_df_inc_cap(df: pd.DataFrame, df_3: pd.DataFrame, df_4: pd.DataFrame, train):
    # print(list(df))
    # кол-во инцидентов не мб отрицательным
    df[df.num_inc_pred < 0] = 0

    df.num_inc_pred = df.num_inc_pred.astype(int)

    # для кап ремонта исключим дома, которые были построены недавно
    #df = df[df['Год постройки'] < 2000]

    #ограничим год постройки
    df = df[df['Год постройки'] > 1850]

    #train mode
    if train == True:
        # возьмем пересечение домов с табл кап рем
        unom_list_1 = df.unom.astype(int).to_list() # all objects
        unom_list_3 = df_3.unom.to_list() #objects for cap rem in 2022
        unom_1 = set(unom_list_1) #18432 items
        unom_3 = set(unom_list_3) #373 items
        unom_for_cap = unom_1.intersection(unom_3)

        df_cap = df[df.unom.isin(unom_for_cap)]

        # табл работ по кап рем за 2022
        df_3_4 = create_df_3_4(df_3, df_4)[['name', 'unom']]

        all_work_names = df_3_4.name.unique()
        works_for_unom_dict = {} # dict unom: work list
        for u in unom_3: # cap work unoms
            works_for_unom_dict[u] = list(df_3_4[df_3_4.unom == u].name)
        for work_name in all_work_names: #all work names
            col_work = []
            for _, v in works_for_unom_dict.items():
                if work_name in v: #if work in works list for unom
                    col_work.append(1)
                else:
                    col_work.append(0)
            df_cap.loc[:, work_name] = col_work

        return df_cap
    # predict mode
    else:
        return df
